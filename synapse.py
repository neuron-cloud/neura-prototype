# -*- coding: utf-8 -*-
"""Synapse

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15FPPT7yM3GJTmyzRjJkMUQPZq2aWQRjt
"""

import re
import time
import traceback

# === Enhanced Abbreviation Dictionary ===
abbreviation_map = {
    # Common medical prefixes
    "pmh": "past medical history",
    "hx": "history",
    "s/p": "status post",
    "p/t": "presenting to",
    "p/w": "presented with",
    "c/f": "concern for",
    "c/b": "complicated by",
    "c/t": "compared to",
    "c/s": "consult",
    "w/": "with",
    "w/o": "without",
    "wo": "without",
    "wwo": "with and without",
    "b/b": "bowel or bladder",
    "2/2": "secondary to",

    # Locations and facilities
    "ED": "emergency department",
    "OSH": "outside hospital",
    "CCH": "Cook County Hospital",
    "NSGY": "neurosurgery",

    # Imaging
    "CTA": "computed tomography angiography",
    "CTH": "CT head",
    "CAP": "chest abdomen pelvis",
    "MRI": "magnetic resonance imaging",
    "XR": "x-ray",

    # Procedures
    "ACDF": "anterior cervical discectomy and fusion",
    "lami": "laminectomy",
    "lamis": "laminectomies",

    # Conditions
    "tSAH": "traumatic subarachnoid hemorrhage",
    "SDH": "subdural hematoma",
    "aSDH": "acute subdural hematoma",
    "mets": "metastases",
    "AMS": "altered mental status",
    "AVN": "avascular necrosis",
    "fx": "fracture",
    "comp fx": "compression fracture",

    # Body parts and directions
    "TP": "transverse process",
    "SP": "spinous process",
    "BL": "bilateral",
    "Rt": "right",
    "Lt": "left",
    "L": "left",
    "R": "right",
    "RUE": "right upper extremity",
    "LUE": "left upper extremity",
    "RLE": "right lower extremity",
    "LLE": "left lower extremity",
    "BUE": "bilateral upper extremities",
    "BLE": "bilateral lower extremities",
    "RUL": "right upper lobe",
    "LBP": "low back pain",

    # Examination terms
    "DTR": "deep tendon reflex",
    "DTRs": "deep tendon reflexes",
    "TTP": "tenderness to palpation",
    "MAES": "moves all extremities spontaneously",
    "maes": "moves all extremities spontaneously",
    "EHL": "extensor hallucis longus",

    # Orientation
    "ox0": "not oriented to person, place, or time",
    "ox1": "oriented to person only",
    "ox2": "oriented to person and place or time",
    "ox3": "oriented to person, place, and time",
    "GCS": "Glasgow Coma Scale",

    # Movement responses
    "loc": "localizes to pain",
    "wd": "withdraws to pain",

    # Trauma
    "GLF": "ground level fall",
    "LOC": "loss of consciousness",
    "BHT": "blunt head trauma",
    "MVC": "motor vehicle collision",
    "MVA": "motor vehicle accident",

    # Patient state
    "ADLs": "activities of daily living",
    "ACAP": "anticoagulant or antiplatelet therapy",
    "PVR": "post-void residual",

    # Anatomical regions
    "T-spine": "thoracic spine",
    "L-spine": "lumbar spine",
    "C-spine": "cervical spine",

    # Time descriptors
    "dx": "diagnosed",
    "x3d": "for 3 days",
    "x2d": "for 2 days",
    "x4d": "for 4 days",
    "x10d": "for 10 days",
    "x1w": "for 1 week",
    "x1mo": "for 1 month",

    # Labs
    "Na": "sodium",
    "CBC": "complete blood count",
    "BMP": "basic metabolic panel",
    "Coags": "coagulation studies",
    "HH": "hemoglobin hematocrit",
    "PLT": "platelets",
    "PT": "prothrombin time",
    "INR": "international normalized ratio",
    "EtOH": "alcohol",

    # Status descriptors
    "neg": "negative",
    "nl": "normal",
    "wnl": "within normal limits",
    "N/V": "nausea and vomiting",
    "HA": "headache",
    "Pt": "patient",
    "pt": "patient",
    "s/s": "signs and symptoms",
    "AFO": "ankle-foot orthosis",
    "↓": "decreased",
    "↑": "increased",

    # Comorbidities
    "HTN": "hypertension",
    "HLD": "hyperlipidemia",
    "HF": "heart failure",
    "PE": "pulmonary embolism",
    "DVT": "deep vein thrombosis",
    "Ca": "cancer",

    # Treatments
    "PT": "physical therapy",
    "Tx": "treatment",
    "ASA": "aspirin",
    "tx": "treatment"
}

# === Improved Abbreviation Expansion ===
def expand_abbreviations(blurb, dictionary, logger=None):
    """
    Improved abbreviation expansion with context awareness and logging
    """
    if not blurb:
        return blurb, []

    expanded_terms = set()
    blurb_original = blurb

    try:
        # First pass: complete word matches (with boundaries)
        for abbr, full in dictionary.items():
            # Skip very short abbreviations that might cause issues
            if len(abbr) <= 1:
                continue

            # Use word boundaries for complete word matches
            pattern = r'\b' + re.escape(abbr) + r'\b'
            matches = re.findall(pattern, blurb, re.IGNORECASE)

            if matches:
                expanded_terms.add(abbr)
                blurb = re.sub(pattern, full, blurb, flags=re.IGNORECASE)

        # Second pass: special patterns without boundaries
        special_patterns = {
            r's/p': 'status post',
            r'c/f': 'concern for',
            r'p/t': 'presenting to',
            r'c/t': 'compared to',
            r'c/b': 'complicated by',
            r'c/s': 'consult',
            r'w/': 'with',
            r'w/o': 'without',
            r'b/b': 'bowel or bladder',
            r'2/2': 'secondary to',
            r'p/w': 'presented with'
        }

        for pattern, replacement in special_patterns.items():
            matches = re.findall(re.escape(pattern), blurb, re.IGNORECASE)
            if matches:
                expanded_terms.add(pattern)
                blurb = re.sub(re.escape(pattern), replacement, blurb, flags=re.IGNORECASE)

        # Log expansion results if logger provided
        if logger:
            logger.app_logger.debug(f"Expanded {len(expanded_terms)} abbreviations: {', '.join(expanded_terms)}")

        return blurb, list(expanded_terms)

    except Exception as e:
        error_msg = f"Error in abbreviation expansion: {str(e)}"
        if logger:
            logger.log_error(
                component="abbreviation_expansion",
                error_code="EXPANSION_ERROR",
                error_message=error_msg,
                stack_trace=traceback.format_exc()
            )
        # Return original text if expansion fails
        return blurb_original, []

# === Enhanced Negation Detection ===
def is_negated(term, blurb):
    """
    Enhanced negation detection with more patterns and context awareness
    """
    if not term or not blurb:
        return False

    # Preprocess term for better matching
    term = term.strip().lower()
    blurb_lower = blurb.lower()

    # Parse the text into sentences to restrict negation scope
    sentences = re.split(r'[.!?]\s+', blurb_lower)

    # First check for common "denial terms" in sentences containing the term
    for sentence in sentences:
        if term in sentence:
            # If sentence contains term and starts with or includes denial patterns
            denial_patterns = [
                r'denies', r'denied', r'no', r'not', r'negative',
                r'absence of', r'without', r'hasn\'t', r'doesn\'t',
                r'has not', r'does not', r'not (?:having|experiencing|showing)',
                r'hasn\'t endorsed', r'hasn\'t had', r'hasn\'t experienced'
            ]

            if any(re.search(pattern, sentence) for pattern in denial_patterns):
                # Check if term appears in a list after denial
                for pattern in denial_patterns:
                    match = re.search(pattern, sentence)
                    if match:
                        denial_pos = match.end()
                        content_after = sentence[denial_pos:]

                        # If the term appears in content after denial, it's likely negated
                        if term in content_after:
                            # Handle the special case where a double negative appears
                            if not re.search(r'not.+?(?:denied|negative|absent)', sentence):
                                return True

    # Check if term appears directly after a denial term with possible modifiers between
    direct_negation_patterns = [
        r"denies\s+(?:\w+\s+){0,5}" + re.escape(term),
        r"denied\s+(?:\w+\s+){0,5}" + re.escape(term),
        r"negative\s+(?:for\s+)?(?:\w+\s+){0,3}" + re.escape(term),
        r"no\s+(?:\w+\s+){0,3}" + re.escape(term),
        r"not\s+(?:\w+\s+){0,3}" + re.escape(term),
        r"without\s+(?:\w+\s+){0,3}" + re.escape(term),
        r"hasn'?t\s+(?:had|experienced|shown|exhibited)\s+(?:\w+\s+){0,3}" + re.escape(term),
        r"doesn'?t\s+(?:have|show|exhibit)\s+(?:\w+\s+){0,3}" + re.escape(term),
        r"has\s+not\s+(?:had|experienced|shown|exhibited)\s+(?:\w+\s+){0,3}" + re.escape(term),
        r"does\s+not\s+(?:have|show|exhibit)\s+(?:\w+\s+){0,3}" + re.escape(term),
        r"absence\s+of\s+(?:\w+\s+){0,3}" + re.escape(term)
    ]

    for pattern in direct_negation_patterns:
        if re.search(pattern, blurb_lower):
            return True

    # Check for "not endorsed" and similar phrases
    has_not_endorsed_patterns = [
        r"has\s+not\s+endorsed",
        r"have\s+not\s+endorsed",
        r"hasn'?t\s+endorsed",
        r"have\s+not\s+experienced",
        r"has\s+not\s+experienced"
    ]

    for pattern in has_not_endorsed_patterns:
        match = re.search(pattern, blurb_lower)
        if match:
            position = match.end()
            content_after = blurb_lower[position:]
            if term in content_after:
                # Check for any "except" or "but" phrases that might negate the negation
                if not re.search(r'except|but', content_after[:content_after.find(term)]):
                    return True

    # Check for signs and symptoms pattern which often negates multiple symptoms
    if re.search(r'denies\s+(?:all\s+)?s/s', blurb_lower) or re.search(r'denies\s+(?:all\s+)?signs\s+and\s+symptoms', blurb_lower):
        # Common symptoms that would be negated by denying all signs and symptoms
        common_symptoms = [
            "pain", "weakness", "numbness", "paresthesia", "dysesthesia", "anesthesia",
            "radiculopathy", "myelopathy", "sensory deficit", "motor deficit",
            "saddle anesthesia", "bowel incontinence", "bladder incontinence"
        ]

        if any(symptom in term for symptom in common_symptoms):
            return True

    return False

# === Enhanced Baseline Deficit Detector ===
def is_baseline_deficit_mentioned(blurb_lower):
    """
    Improved detection of baseline/chronic deficits in clinical text
    """
    if not blurb_lower:
        return False

    baseline_keywords = [
        "baseline", "chronic", "longstanding", "known",
        "unchanged", "history of", "hx of", "per wife", "per family",
        "baseline dementia", "baseline confusion", "baseline deficit",
        "chronic condition", "prior deficit", "previous deficit",
        "always has", "usual state", "chronically", "previously known"
    ]

    # More sophisticated pattern matching for baseline mentions
    baseline_patterns = [
        r'\b(?:has|had|with)\s+(?:known|chronic|baseline|longstanding|previous)\s+(?:\w+\s+){0,3}(?:deficit|condition|symptom|finding)',
        r'\b(?:at|returns to)\s+baseline\b',
        r'\b(?:consistent|compared) with baseline\b',
        r'\b(?:per|according to)\s+(?:wife|husband|family|daughter|son|caregiver|chart)(?:\s+(?:patient|pt) has|\s+(?:this|that) is)\s+baseline',
        r'\bpreviously\s+(?:diagnosed|documented|noted|known)\b'
    ]

    # Check for keyword matches
    keyword_match = any(phrase in blurb_lower for phrase in baseline_keywords)

    # Check for pattern matches
    pattern_match = any(re.search(pattern, blurb_lower) for pattern in baseline_patterns)

    return keyword_match or pattern_match

# === Comprehensive Exam Components Extraction ===
def extract_exam_components(blurb, logger=None):
    """
    Generalized physical exam parsing that works for any format
    Designed to detect all neurological exam components without special cases
    """
    if not blurb:
        return []

    findings = []
    blurb_lower = blurb.lower()

    # First, identify the exam section if present
    exam_section = None
    exam_section_patterns = [
        r'exam(?:\s*[-:]\s*)(.*?)(?:\n\n|\Z)',
        r'(?:physical|neuro(?:logical)?|motor)\s+exam(?:\s*[-:]\s*)(.*?)(?:\n\n|\Z)',
        r'(?:physical|neurological) findings(?:\s*[-:]\s*)(.*?)(?:\n\n|\Z)'
    ]

    for pattern in exam_section_patterns:
        match = re.search(pattern, blurb_lower, re.DOTALL)
        if match:
            exam_section = match.group(1).strip()
            break

    # If no explicit exam section found, use the whole blurb
    if not exam_section:
        exam_section = blurb_lower

    # === CONSCIOUSNESS AND ORIENTATION ASSESSMENT ===
    # Check for GCS score
    gcs_pattern = r'gcs\s*(?:of|is|at|score)?\s*(\d+)'
    gcs_match = re.search(gcs_pattern, exam_section)

    if gcs_match:
        gcs_score = int(gcs_match.group(1))
        if gcs_score == 15:
            findings.append("✅ Full consciousness: GCS 15.")
        elif gcs_score >= 13:
            findings.append("🔍 Mild consciousness impairment: GCS " + str(gcs_score))
        elif gcs_score >= 9:
            findings.append("⚠️ Moderate consciousness impairment: GCS " + str(gcs_score))
        else:
            findings.append("🚨 Severe consciousness impairment: GCS " + str(gcs_score))

    # Check for arousal descriptions
    arousal_patterns = {
        r'(?:eyes?\s+open(?:ing)?)\s+(?:to|with)\s+(?:heavy\s+)?(?:stim|stimulation|pain)':
            "🧠 Decreased arousal level—requires stimulation for eye opening.",
        r'alert|awake|wide awake':
            "✅ Alert and awake.",
        r'drowsy|lethargic|somnolent':
            "🧠 Decreased arousal—drowsy/lethargic."
    }

    for pattern, message in arousal_patterns.items():
        match = re.search(pattern, exam_section)
        if match and not is_negated(match.group(0), blurb_lower):
            findings.append(message)

    # Check for orientation status
    orientation_patterns = {
        r'\box0\b|not oriented|disoriented': "🧠 Altered mental status: Ox0 or disoriented.",
        r'\box1\b|oriented to person only': "🧠 Partial orientation: Ox1.",
        r'\box2\b|oriented to person and (place|time)': "🧠 Oriented to person and place: Ox2.",
        r'\box3\b|oriented x3|fully oriented': "✅ Fully oriented: Ox3."
    }

    for pattern, message in orientation_patterns.items():
        match = re.search(pattern, exam_section)
        if match and not is_negated(match.group(0), blurb_lower):
            findings.append(message)
            break  # Only add the most specific orientation finding

    # === MOTOR RESPONSES TO PAINFUL STIMULI ===
    # Check for localizing and withdrawal responses
    motor_response_patterns = {
        r'bue\s+loc': "🧠 Localizes to pain in bilateral upper extremities.",
        r'ble\s+wd': "🧠 Withdrawal response in bilateral lower extremities.",
        r'bue\s+loc\s+ble\s+wd': "🧠 Localizes in upper extremities, withdraws in lower extremities.",
        r'(?:bilateral|bl|both|rt|lt|right|left)\s+(?:upper|lower|ue|le|extremities|extremity)\s+(?:localizes?|loc)\b':
            "🧠 Localizes to pain in specified extremities.",
        r'(?:bilateral|bl|both|rt|lt|right|left)\s+(?:upper|lower|ue|le|extremities|extremity)\s+(?:withdraws?|wd)\b':
            "🧠 Withdrawal response in specified extremities.",
        r'(?:does not follow|unable to follow) commands': "🧠 Decreased level of consciousness—unable to follow commands.",
        r'follows? commands': "✅ Follows commands appropriately."
    }

    for pattern, message in motor_response_patterns.items():
        match = re.search(pattern, exam_section)
        if match and not is_negated(match.group(0), blurb_lower):
            findings.append(message)

    # === CRANIAL NERVE EXAMINATION ===
    # Check for facial droop, tongue deviation, and dysarthria
    cranial_nerve_patterns = {
        r'(?:facial|face)\s+(?:droop|weakness|asymmetry)':
            "🦴 Facial droop—possible cranial nerve VII weakness.",
        r'(?:tongue|lingual)\s+(?:deviation|weakness)':
            "🦴 Tongue deviation—possible cranial nerve XII weakness.",
        r'(?:slurred|dysarthric)\s+speech':
            "🧠 Dysarthria/slurred speech—monitor for progression."
    }

    for pattern, message in cranial_nerve_patterns.items():
        match = re.search(pattern, exam_section)
        if match and not is_negated(match.group(0), blurb_lower):
            findings.append(message)

    # === MOTOR STRENGTH ASSESSMENT ===
    # Create a dictionary for limb name standardization
    limb_map = {
        "rue": "RIGHT UPPER EXTREMITY",
        "lue": "LEFT UPPER EXTREMITY",
        "rle": "RIGHT LOWER EXTREMITY",
        "lle": "LEFT LOWER EXTREMITY",
        "bue": "BILATERAL UPPER EXTREMITIES",
        "ble": "BILATERAL LOWER EXTREMITIES",
        "right arm": "RIGHT UPPER EXTREMITY",
        "left arm": "LEFT UPPER EXTREMITY",
        "right upper extremity": "RIGHT UPPER EXTREMITY",
        "left upper extremity": "LEFT UPPER EXTREMITY",
        "right leg": "RIGHT LOWER EXTREMITY",
        "left leg": "LEFT LOWER EXTREMITY",
        "right lower extremity": "RIGHT LOWER EXTREMITY",
        "left lower extremity": "LEFT LOWER EXTREMITY",
        "r arm": "RIGHT UPPER EXTREMITY",
        "l arm": "LEFT UPPER EXTREMITY",
        "r leg": "RIGHT LOWER EXTREMITY",
        "l leg": "LEFT LOWER EXTREMITY",
        "r upper": "RIGHT UPPER EXTREMITY",
        "l upper": "LEFT UPPER EXTREMITY",
        "r lower": "RIGHT LOWER EXTREMITY",
        "l lower": "LEFT LOWER EXTREMITY",
        "rt arm": "RIGHT UPPER EXTREMITY",
        "lt arm": "LEFT UPPER EXTREMITY",
        "rt leg": "RIGHT LOWER EXTREMITY",
        "lt leg": "LEFT LOWER EXTREMITY"
    }

    # Muscle groups dictionary
    muscle_groups = {
        "RIGHT UPPER EXTREMITY": ["shoulder abduction", "elbow flexion", "elbow extension", "wrist extension", "handgrip"],
        "LEFT UPPER EXTREMITY": ["shoulder abduction", "elbow flexion", "elbow extension", "wrist extension", "handgrip"],
        "RIGHT LOWER EXTREMITY": ["hip flexion", "knee extension", "ankle dorsiflexion", "EHL", "ankle plantarflexion"],
        "LEFT LOWER EXTREMITY": ["hip flexion", "knee extension", "ankle dorsiflexion", "EHL", "ankle plantarflexion"]
    }

    # Track processed extremities to avoid duplicates
    processed_extremities = set()

    # Normalize text for better pattern matching
    exam_normalized = exam_section

    # Replace various separators with standard slash
    exam_normalized = re.sub(r'(\d+[-+]?)\s+(\d+[-+]?)', r'\1/\2', exam_normalized)
    exam_normalized = re.sub(r'(\d+[-+]?)[,;](\d+[-+]?)', r'\1/\2', exam_normalized)

    # Standardize strength notation
    exam_normalized = re.sub(r'(\d+)s', r'\1', exam_normalized)

    # Find motor strength patterns with various formats
    # Pattern 1: Complex multiple muscle strength (e.g., RUE 5/5/5/4-/4)
    complex_pattern = r'(rue|lue|rle|lle)(?:\s*[:;-])?\s*(?:\()?(\d+[-+]?(?:[\/\s,.-]?\d+[-+]?){2,4})(?:\))?'
    complex_matches = re.finditer(complex_pattern, exam_normalized, re.IGNORECASE)

    for match in complex_matches:
        extremity = match.group(1).lower()
        if extremity in processed_extremities:
            continue

        # Standardize the extremity name
        extremity_name = limb_map.get(extremity, extremity.upper())

        # Extract strength values
        strength_text = match.group(2)
        values = re.findall(r'(\d+[-+]?)', strength_text)

        # Identify weaknesses
        weak_values = []
        for i, val in enumerate(values):
            if val.strip() not in ['5', '5+']:
                # Get the muscle name if available
                if extremity_name in muscle_groups and i < len(muscle_groups[extremity_name]):
                    muscle_name = muscle_groups[extremity_name][i]
                else:
                    muscle_name = f"muscle {i+1}"
                weak_values.append((muscle_name, val))

        # Add findings if weakness is present
        if weak_values:
            processed_extremities.add(extremity)
            weakness_details = ", ".join([f"{muscle}: {strength}" for muscle, strength in weak_values])
            findings.append(f"🦴 Weakness in {extremity_name}: {weakness_details}")

    # Pattern 2: Simple strength scores (e.g., LUE 4+/5)
    simple_pattern = r'(rue|lue|rle|lle|right arm|left arm|right leg|left leg)\s+(\d+[-+]?)/5'
    simple_matches = re.finditer(simple_pattern, exam_section, re.IGNORECASE)

    for match in simple_matches:
        extremity = match.group(1).lower()
        if extremity in processed_extremities:
            continue

        strength = match.group(2)
        if strength not in ['5', '5+']:
            processed_extremities.add(extremity)
            extremity_name = limb_map.get(extremity, extremity.upper())
            findings.append(f"🦴 Weakness in {extremity_name}: {strength}/5")

    # Pattern 3: Drift patterns
    drift_pattern = r'(?:subtle|mild|slight)?\s+((?:right|left|rt|lt|r|l)(?:\s+(?:arm|leg|upper|lower|ue|le|extremity))?|rue|lue|rle|lle)\s+drift'
    drift_matches = re.finditer(drift_pattern, exam_section, re.IGNORECASE)

    for match in drift_matches:
        extremity = match.group(1).lower()
        if extremity in processed_extremities:
            continue

        # Determine the full extremity name
        if extremity in limb_map:
            extremity_name = limb_map[extremity]
        else:
            # Try to build extremity name from parts
            extremity_name = ""
            if re.search(r'(right|rt|r)\b', extremity):
                extremity_name = "RIGHT "
            elif re.search(r'(left|lt|l)\b', extremity):
                extremity_name = "LEFT "

            if re.search(r'(arm|upper|ue)\b', extremity):
                extremity_name += "UPPER EXTREMITY"
            elif re.search(r'(leg|lower|le)\b', extremity):
                extremity_name += "LOWER EXTREMITY"
            else:
                extremity_name += "EXTREMITY"

        processed_extremities.add(extremity)
        findings.append(f"🦴 Weakness noted in {extremity_name} (drift)")

    # === REFLEX ASSESSMENT ===
    # Check for pathological reflexes
    reflex_patterns = {
        r'hoffmans?\b|hoffman\'?s?\s+sign':
            "⚠️ Hoffman's sign—UMN risk.",
        r'clonus\b':
            "⚠️ Clonus detected—possible UMN sign.",
        r'babinski\b|babinski\'?s?\s+sign':
            "⚠️ Babinski reflex noted.",
        r'(?:hyperreflexia|[\d][\+]?\s+dtrs?|dtrs?\s+[\d][\+]?)':
            "⚠️ Hyperreflexia—monitor for UMN lesion.",
        r'(?:hyporeflexia|areflexia|0\s+dtrs?|dtrs?\s+0)':
            "⚠️ Hyporeflexia—possible LMN involvement.",
        r'(?:normal\s+reflexes|2\+?\s+dtrs?|dtrs?\s+2\+?)':
            "✅ Reflexes within normal limits.",
        r'no\s+(?:path(?:ological)?|abnormal)\s+reflexes':
            "✅ No pathological reflexes noted."
    }

    for pattern, message in reflex_patterns.items():
        matches = re.finditer(pattern, exam_section, re.IGNORECASE)
        for match in matches:
            if not is_negated(match.group(0), blurb_lower):
                findings.append(message)
                break

    # === SENSORY ASSESSMENT ===
    # Check for sensory deficits
    sensory_patterns = {
        r'(?:decreased|diminished|reduced|impaired)\s+sensation':
            "🧠 Sensory deficit present.",
        r'numbness\b|paresthesia\b|dysesthesia\b':
            "🧠 Sensory deficit present.",
        r'sensation\s+(?:is\s+)?(?:intact|normal|preserved)|silt':
            "✅ Sensation intact."
    }

    for pattern, message in sensory_patterns.items():
        match = re.search(pattern, exam_section, re.IGNORECASE)
        if match and not is_negated(match.group(0), blurb_lower):
            # Check if it's a baseline condition for sensory deficit
            if "deficit" in message and is_baseline_deficit_mentioned(blurb_lower):
                findings.append("✅ Sensory findings noted but consistent with baseline.")
            else:
                findings.append(message)
            break

    # === CAUDA EQUINA ASSESSMENT ===
    # Check for saddle anesthesia
    saddle_pattern = r'saddle\s+anesthesia'
    saddle_match = re.search(saddle_pattern, blurb_lower, re.IGNORECASE)
    if saddle_match and not is_negated(saddle_match.group(0), blurb_lower):
        findings.append("⚠️ Saddle anesthesia—possible cauda equina.")

    # Check for bowel/bladder dysfunction
    bowel_bladder_pattern = r'(?:bowel|bladder)\s+(?:incontinence|retention|dysfunction)'
    bowel_bladder_match = re.search(bowel_bladder_pattern, blurb_lower, re.IGNORECASE)
    if bowel_bladder_match and not is_negated(bowel_bladder_match.group(0), blurb_lower):
        findings.append("⚠️ Bowel/bladder dysfunction—evaluate for cauda equina.")

    # Check for rectal tone
    rectal_tone_pattern = r'\+rectal\s+tone|normal\s+rectal\s+tone|rectal\s+tone\s+(?:present|intact)'
    rectal_tone_match = re.search(rectal_tone_pattern, exam_section, re.IGNORECASE)
    if rectal_tone_match and not is_negated(rectal_tone_match.group(0), blurb_lower):
        findings.append("✅ Rectal tone intact.")

    # === SPINE EXAMINATION ===
    spine_patterns = {
        r'(?:cervical|neck)\s+(?:tenderness|ttp|pain\s+on\s+palpation)':
            "⚠️ Cervical spine tenderness—assess NEXUS clearance.",
        r'(?:thoracic|lumbar|mid-?back|low-?back|midline)\s+(?:tenderness|ttp|pain\s+on\s+palpation)':
            "🔍 Spine tenderness—correlate with imaging."
    }

    for pattern, message in spine_patterns.items():
        match = re.search(pattern, blurb_lower, re.IGNORECASE)
        if match and not is_negated(match.group(0), blurb_lower):
            findings.append(message)

    # === INTACT EXCEPT PATTERN ===
    # Parse the "intact except" pattern to extract all exceptions
    intact_except_pattern = r'intact\s+except\s+(?:for\s+)?(.*?)(?:\.|$)'
    intact_except_match = re.search(intact_except_pattern, exam_section, re.IGNORECASE)

    if intact_except_match:
        exception_text = intact_except_match.group(1).strip()

        # Split the exceptions by commas or "and"
        exceptions = re.split(r',|\s+and\s+', exception_text)

        for exception in exceptions:
            exception = exception.strip()
            if not exception:
                continue

            # Check if we already have findings about this exception
            already_covered = False
            for finding in findings:
                if exception.lower() in finding.lower():
                    already_covered = True
                    break

            # If not already covered, add as an individual finding
            if not already_covered:
                findings.append(f"🔍 Finding: {exception}")

    # === NORMAL EXAM HANDLING ===
    # Check for completely normal/intact exam if no findings yet
    if not findings:
        normal_patterns = [
            r'exam\s*[:-]\s*intact',
            r'neurological(?:ly)?\s+intact',
            r'neuro(?:logically)?\s+intact',
            r'neur(?:o)?\s+exam\s+(?:is\s+)?intact',
            r'normal\s+(?:neuro|neurological|neurologic)\s+exam',
            r'exam\s*[:-]\s*(?:appears|essentially)\s+normal',
            r'no\s+focal\s+(?:neuro(?:logical)?|neurologic)\s+(?:deficits|findings)'
        ]

        for pattern in normal_patterns:
            match = re.search(pattern, exam_section, re.IGNORECASE)
            if match and not re.search(r'intact\s+except', exam_section, re.IGNORECASE):
                findings.append("✅ Normal neurological examination.")
                break

    # === ENSURE WE HAVE A FINDING IF EXAM IS MENTIONED ===
    # If there's an exam section but we haven't found any specific findings
    if not findings and re.search(r'exam(?:\s*:|\s*-)', blurb_lower):
        if re.search(r'normal|intact|negative|unremarkable', exam_section):
            findings.append("✅ Exam appears to be normal.")
        else:
            findings.append("⚠️ Exam mentioned but findings unclear—manual review advised.")

    return findings

# === Universal Risk Flagging Engine ===
def risk_flag(blurb, logger=None):
    """
    Universal risk flagging engine with generalized pattern detection
    """
    if not blurb:
        return "⚠️ Empty input—manual review advised."

    start_time = time.time()

    try:
        # Expand abbreviations
        expanded_blurb, expanded_terms = expand_abbreviations(blurb, abbreviation_map, logger)
        blurb_lower = expanded_blurb.lower()

        flags = []
        seen_flags = set()

        # --- NEUROLOGICAL STATUS FLAGS ---
        # Check for overall level of consciousness
        gcs_pattern = r'gcs\s*(?:of|is|at|score)?\s*(\d+)'
        gcs_match = re.search(gcs_pattern, blurb_lower)

        has_gcs15 = False
        if gcs_match:
            gcs_score = int(gcs_match.group(1))
            if gcs_score == 15:
                has_gcs15 = True
                message = "✅ Full consciousness: GCS 15."
                flags.append(message)
                seen_flags.add(message)
            elif gcs_score >= 13:
                message = "🔍 Mild consciousness impairment: GCS " + str(gcs_score)
                flags.append(message)
                seen_flags.add(message)
            elif gcs_score >= 9:
                message = "⚠️ Moderate consciousness impairment: GCS " + str(gcs_score)
                flags.append(message)
                seen_flags.add(message)
            else:
                message = "🚨 Severe consciousness impairment: GCS " + str(gcs_score)
                flags.append(message)
                seen_flags.add(message)
        else:
            # Check for other GCS 15 mentions without explicit score
            gcs15_pattern = r'gcs\s*(?:of|is|at|score)?\s*15|glasgow\s+(?:coma\s+)?(?:scale|score)\s*(?:of|is|at)?\s*15'
            if re.search(gcs15_pattern, blurb_lower):
                has_gcs15 = True
                message = "✅ Full consciousness: GCS 15."
                flags.append(message)
                seen_flags.add(message)

        # --- STRUCTURAL BRAIN INJURY RISK ---
        # Check for brain shift or herniation
        structural_brain_patterns = {
            r'(?:(?:brain|midline|mls|middle?line)\s+shift)|(?:\d+\s*mm\s+(?:brain|midline|middle?line)\s+shift)|(?:(?:brain|midline)\s+shifted)':
                "⚠️ High-risk: Possible brain shift. Escalate.",
            r'herniat(?:ing|ion|ed)':
                "🚨 Critical neuro compromise—brain herniation risk, immediate eval.",
            r'(?:increased|elevated|high)\s+(?:icp|intracranial pressure)':
                "⚠️ Elevated ICP risk—monitor for decompensation."
        }

        for pattern, message in structural_brain_patterns.items():
            match = re.search(pattern, blurb_lower)
            if match and not is_negated(match.group(0), blurb_lower):
                if message not in seen_flags:
                    flags.append(message)
                    seen_flags.add(message)

        # --- AIRWAY ASSESSMENT ---
        airway_patterns = {
            r'intubated': "🚨 Critical neuro compromise—secure airway, immediate eval.",
            r'airway\s+compromise': "🚨 Airway compromise—immediate intervention required."
        }

        for pattern, message in airway_patterns.items():
            match = re.search(pattern, blurb_lower)
            if match and not is_negated(match.group(0), blurb_lower):
                if message not in seen_flags:
                    flags.append(message)
                    seen_flags.add(message)

        # --- CONSCIOUSNESS ASSESSMENT ---
        if not has_gcs15:  # Skip consciousness checks if GCS 15 is present
            consciousness_patterns = {
                r'(?:altered|change in|worsening) (?:mental status|ams)':
                    "🧠 Altered mental status—evaluate for neurological event.",
                r'localizes to pain|loc':
                    "🧠 Decreased consciousness—GCS trending.",
                r'withdraws to pain|wd':
                    "🧠 Significantly decreased consciousness—neurological emergency.",
                r'eyes open to (?:pain|stim)':
                    "🧠 Severely decreased consciousness—neurological emergency.",
                r'not (?:following|obey) commands':
                    "🧠 Impaired comprehension or arousal—AMS workup needed."
            }

            for pattern, message in consciousness_patterns.items():
                match = re.search(pattern, blurb_lower)
                # Avoid flagging if there's a clear statement of normal exam
                if match and not is_negated(match.group(0), blurb_lower) and not re.search(r'exam\s*[:-]\s*intact', blurb_lower):
                    # Check if this is a baseline condition
                    if not is_baseline_deficit_mentioned(blurb_lower):
                        if message not in seen_flags:
                            flags.append(message)
                            seen_flags.add(message)

        # --- ORIENTATION ASSESSMENT ---
        orientation_patterns = {
            r'\box0\b|not oriented|disoriented':
                "🧠 Altered mental status: Ox0 or disoriented.",
            r'\box1\b|oriented to person only':
                "🧠 Partial orientation: Ox1.",
            r'\box2\b|oriented to person and (place|time)':
                "🧠 Oriented to person and place: Ox2.",
            r'\box3\b|oriented x3|fully oriented':
                "✅ Fully oriented: Ox3."
        }

        for pattern, message in orientation_patterns.items():
            match = re.search(pattern, blurb_lower)
            if match and not is_negated(match.group(0), blurb_lower):
                if message not in seen_flags:
                    flags.append(message)
                    seen_flags.add(message)
                break  # Only add the most specific orientation finding

        # --- COAGULOPATHY RISK ---
        # Check if coagulation studies are pending
        coags_pending = "coags pending" in blurb_lower or "coagulation studies pending" in blurb_lower

        if not coags_pending:
            coag_patterns = {
                r'(?:abnormal|elevated)\s+(?:coags|coagulation|inr)':
                    "🔎 Coagulopathy risk—evaluate before intervention.",
                r'coagulopathy':
                    "🔎 Coagulopathy risk—evaluate before intervention.",
                r'inr\s*(?:>|greater than|above)\s*(?:1\.5|2)':
                    "🔎 Elevated INR—bleeding risk.",
                r'thrombocytopenia|platelets?\s*(?:<|less than|under)\s*(?:100|50)':
                    "🔎 Low platelets—bleeding risk.",
                r'(?:on|taking)\s+(?:warfarin|coumadin|heparin|lovenox|eliquis|xarelto|pradaxa|edoxaban|rivaroxaban|apixaban|dabigatran)':
                    "🔎 Patient on anticoagulation—manage bleeding risk."
            }

            for pattern, message in coag_patterns.items():
                match = re.search(pattern, blurb_lower)
                if match and not is_negated(match.group(0), blurb_lower):
                    if message not in seen_flags:
                        flags.append(message)
                        seen_flags.add(message)

        # --- FALLS AND FRAILTY RISK ---
        frailty_patterns = {
            r'(?:dementia|severe cognitive impairment)':
                "⚠️ Frailty + fall risk.",
            r'multiple falls|history of falls|fall risk':
                "⚠️ Frailty + fall risk.",
            r'completely dependent|dependent for adls':
                "⚠️ Dependence for ADLs—evaluate frailty.",
            r'age\s*(?:>|over|above)\s*(?:80|85|90)':
                "🔍 Advanced age—consider frailty assessment.",
            r'(?:poor|limited) mobility':
                "🔍 Mobility limitation—fall risk.",
            r'gait\s+instability':
                "🔍 Gait instability—fall risk assessment."
        }

        for pattern, message in frailty_patterns.items():
            match = re.search(pattern, blurb_lower)
            if match and not is_negated(match.group(0), blurb_lower):
                if message not in seen_flags:
                    flags.append(message)
                    seen_flags.add(message)

        # --- TUMOR/CANCER RISKS ---
        tumor_patterns = {
            r'(?:glioblastoma|gbm|glioma|brain tumor)':
                "🧠 Known intracranial neoplasm—monitor for mass effect or recurrence.",
            r'(?:brain|intracranial|cns) (?:metastasis|metastases|mets)':
                "🧠 Brain metastases—monitor for edema and mass effect.",
            r'(?:cervical|thoracic|lumbar|sacral) (?:metastasis|metastases|mets)':
                "⚠️ Spinal metastases—assess stability and cord compression risk.",
            r'(?:cancer|ca|carcinoma|malignancy).*(?:metastatic|metastasis|mets|widespread|disseminated)':
                "🔍 Metastatic disease—evaluate symptom etiology carefully."
        }

        for pattern, message in tumor_patterns.items():
            match = re.search(pattern, blurb_lower)
            if match and not is_negated(match.group(0), blurb_lower):
                if message not in seen_flags:
                    flags.append(message)
                    seen_flags.add(message)

        # --- SPINE STABILITY CONCERNS ---
        spine_patterns = {
            r'(?:c-?spine|cervical spine).*(?:unstable|instability)':
                "⚠️ Cervical spine instability—maintain precautions.",
            r'(?:anterolisthesis|retrolisthesis|spondylolisthesis)':
                "🔍 Spondylolisthesis—assess for instability.",
            r'(?:cervical|thoracic|lumbar) (?:fracture|fx)':
                "⚠️ Spine fracture—evaluate stability and neurological status.",
            r'cord compression|canal stenosis':
                "⚠️ Cord compression risk—monitor neurological status."
        }

        for pattern, message in spine_patterns.items():
            match = re.search(pattern, blurb_lower)
            if match and not is_negated(match.group(0), blurb_lower):
                if message not in seen_flags:
                    flags.append(message)
                    seen_flags.add(message)

        # --- PHYSICAL EXAM ANALYSIS ---
        # Use the comprehensive exam components extraction function
        exam_findings = extract_exam_components(expanded_blurb, logger)

        # Add unique exam findings to our flags list
        for finding in exam_findings:
            if finding not in seen_flags:
                flags.append(finding)
                seen_flags.add(finding)

        # --- SADDLE ANESTHESIA & CAUDA EQUINA DOUBLE-CHECK ---
        # This is a critical safety check for an important clinical finding
        if "saddle anesthesia" in blurb_lower:
            # Check if it's explicitly negated
            if is_negated("saddle anesthesia", blurb_lower):
                # Remove any false positive flags about saddle anesthesia
                flags = [f for f in flags if "Saddle anesthesia" not in f]

        # --- RESOLVE CONTRADICTIONS AND ORGANIZE FLAGS ---

        # Check for critical and specific findings
        has_critical_flags = any(symbol in flag for flag in flags for symbol in ["⚠️", "🚨"])
        has_weakness_flags = any("Weakness" in flag for flag in flags)
        has_sensory_flags = any("Sensory deficit" in flag for flag in flags)
        has_reflex_flags = any(term in flag for flag in flags for term in ["Hoffman", "clonus", "Babinski", "reflexes", "Hyperreflexia"])

        # Remove generic "mostly intact" flags if we have specific findings
        if has_weakness_flags or has_sensory_flags or has_reflex_flags:
            flags = [f for f in flags if not "Mostly intact exam with exception" in f]

        # Remove "normal exam" or "stable" flags if critical flags are present
        if has_critical_flags or has_weakness_flags:
            flags = [f for f in flags if not any(term in f.lower() for term in ["normal neurological examination", "stable neuro exam"])]

        # Sort flags by severity (critical first, then warnings, etc.)
        def flag_priority(flag):
            if "🚨" in flag: return 0  # Critical - highest priority
            if "⚠️" in flag: return 1  # Warning
            if "🦴" in flag: return 2  # Motor findings
            if "🧠" in flag: return 3  # Neuro/sensory findings
            if "🔍" in flag: return 4  # Areas to monitor
            return 5                    # Normal findings - lowest priority

        flags.sort(key=flag_priority)

        # --- RESULT HANDLING ---

        # Add a stable message if all flags are normal
        if flags and all("✅" in flag for flag in flags) and not any("Stable neuro exam" in flag for flag in flags):
            flags.append("✅ Stable neuro exam at this time.")

        # Return message if no flags triggered
        if not flags:
            # Check for explicit mention of normal exam
            if re.search(r'exam\s*[:-]\s*(?:normal|intact|negative|unremarkable)', blurb_lower):
                return "✅ Exam appears normal with no specific findings."
            else:
                return "⚠️ No specific flags triggered—manual review advised."

        # Calculate processing time for logging
        processing_time = int((time.time() - start_time) * 1000)

        # Log the overall processing if logger is provided
        if logger and hasattr(logger, 'log_clinical_processing'):
            logger.log_clinical_processing(
                input_text=blurb,
                abbreviations_expanded=expanded_terms,
                processing_time_ms=processing_time,
                flags_detected=len(flags)
            )

        # Convert to string with newlines
        return "\n".join(flags)

    except Exception as e:
        error_msg = f"Error processing consult text: {str(e)}"
        if logger and hasattr(logger, 'log_error'):
            logger.log_error(
                component="risk_flag_engine",
                error_code="PROCESSING_ERROR",
                error_message=error_msg,
                severity="high",
                stack_trace=traceback.format_exc()
            )
        return "🚨 Error in processing: " + error_msg

# === Function to load and process blurbs from files ===
def load_blurbs_from_txt(filename="demo_blurbs.txt"):
    """Load consult blurbs from a text file with '___' separator"""
    try:
        with open(filename, 'r', encoding='utf-8', errors='replace') as file:
            raw = file.read()

        # Clean up encoding issues
        clean = raw.replace("Ò", "\"").replace("Ó", "\"")

        # Split and return consult blurbs
        return [blurb.strip() for blurb in clean.split('___') if blurb.strip()]
    except Exception as e:
        print(f"❌ Error loading blurbs: {str(e)}")
        return []

# === Run Risk Flagging on Demo Blurbs ===
def process_demo_cases():
    demo_blurbs = load_blurbs_from_txt("demo_blurbs.txt")

    if not demo_blurbs:
        print("❌ No blurbs loaded. Double-check the file and path.")
    else:
        for i, blurb in enumerate(demo_blurbs, start=1):
            print(f"\n📝 Consult #{i}")
            print("-" * 30)
            print(blurb)
            print("-" * 30)
            print("\nSynapse RISK FLAGS:")
            print(risk_flag(blurb))  # Add `logger=logger` here if using logging
            print("=" * 50)

if __name__ == "__main__":
    process_demo_cases()